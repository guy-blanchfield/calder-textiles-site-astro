---
export interface Props {
	videoBase: string;
	videoAutoplay?: string;
	pictureClasses?: string; // e.g. hero__picture
	// might as well have a prop for the fade transition time
	// that will go into a data-attribute
	// it will be used in the css to set duration of the fade in when the image or video is ready to display
	// and also to set the timeout duration of handleHeroTextTransition() (in initialise.ts)
	// i.e. the hero text fade-up has to wait for the image or video fade-in to finish
	transitionDuration?: string; // properties of dataset are strings
}

const { videoBase, videoAutoplay = "true", pictureClasses = "", transitionDuration = "1000ms" } = Astro.props;

const videoSourcePart = `/video/${videoBase}`;

// let's try the 20px blurred image thing
// just so there's not a big blank space while the video loads
// doesn't need to be an imageset, just a single image
const backgroundImageTiny = `url(/images/${videoBase}-20x11.jpg)`;
// the LQIP, currently 1440 x 810
const backgroundImageLQIP = `url(/images/${videoBase}-lqip.jpg)`;
---

<!-- 

- NB autoplay getting set with js below, leave it off here  
- preload=none will stop browser downloading any part of the 
  video unless it has to i.e. when autoplay is set by the js 

-->
<div class="video-container">
	<video
		class="video-element"
		data-source={videoSourcePart}
		data-autoplay={videoAutoplay}
		data-transition-duration={transitionDuration}
		muted
		loop
		playsinline
	>
		<p>Your browser doesn't support HTML video.</p>
	</video>
</div>

<script>
	// this script will run regardless of the conditional render in Hero component
	// and there's quite a lot of it, so put all of it inside a condition

	if (document.querySelector(".video-element")) {
		console.log(`video component script actually running!!`);

		// use a window.innerWidth to target the right video element
		const windowWidth: number = window.innerWidth;
		const videoElement: HTMLVideoElement = document.querySelector(".video-element");
		const videoSrcPrt = videoElement.dataset.source;
		let videoSource: string;
		let videoPixels: string;
		let videoExt: string;

		// is video autoplay (is it somewhere other than the homepage)
		const isVideoAutoplay: boolean = videoElement.dataset.autoplay == "true" ? true : false;

		// 360p was a bit crappy even at 400vw
		// the number is the height of the video btw
		if (windowWidth < 992) {
			videoPixels = "540p";
		} else if (windowWidth < 1200) {
			videoPixels = "720p";
		} else {
			videoPixels = "1080p";
		}

		console.log(`Canplaytype(): ${typeof videoElement?.canPlayType}`);
		// with codec not specified, logs "maybe" on firefox, chrome, edge
		console.log(`Can play webm: ${videoElement?.canPlayType("video/webm")}`);
		// with codec specified, logs "probably" on firefox, chrome, edge
		console.log(`Can play webm codecs=vp9: ${videoElement?.canPlayType('video/webm;codecs="vp9"')}`);
		// NB has to be single quotes with double quotes round the codec e.g. "vp9"
		if (
			typeof videoElement.canPlayType === "function" &&
			videoElement.canPlayType('video/webm;codecs="vp9"') === "probably"
		) {
			videoExt = ".webm";
		} else {
			videoExt = ".mp4";
		}

		videoSource = videoSrcPrt + "-" + videoPixels + videoExt;
		console.log(`videoSource: ${videoSource}`);

		// right, if this isn't the first load, we want to show the video
		// as soon as possible so it doesn't keep showing the blur and transition
		// on every refresh or return to the homepage
		// so set source here, instead of waiting for window.load

		// the play command will come later in initialise.js > handleVideoReady()
		// we want the video to show as soon as possible

		// do we need a condition here at all?
		// why not just set source here and wait for either initialise to video.play()
		// or the onload to set autoplay

		//  seems like we don't!

		// if (sessionStorage.getItem("preloadComplete")) {
		setSource();
		// }

		// temporarily log all this to the screen for testing iOS
		// const videoStatus = document.querySelector(".video-status");
		// videoStatus.innerHTML = ``;
		// videoStatus.innerHTML += `<p>Video Source: ${videoSource}</p>`;
		// videoStatus.innerHTML += `<p>Video Ext: ${videoExt}</p>`;
		// videoStatus.innerHTML += `<p>Can play webm/vp9: ${videoElement?.canPlayType('video/webm;codecs="vp9"')}`;

		// console.log(`querying for ${queryClass}`);
		// const videoElement = document.querySelector(queryClass);
		// const videoElement = document.querySelector('.video-element--xl');

		function addAutoplay() {
			// add autoplay if the data-attribute is set by props
			// i.e. if the video is somewhere else on the site other than the home page
			// there won't be a preloader, pass the autoplay prop to this component as 'true'
			// otherwise leave the play() to preloader component
			console.log(`dataset.autoplay: ${isVideoAutoplay}`);
			if (isVideoAutoplay) {
				videoElement.setAttribute("autoplay", "");
			}
		}

		// NB setSource() used be called from 2 places
		// either after all the vars have been set (above)
		// or in the window.onload callback (below)
		// but now it's just called once after the vars are set
		function setSource() {
			// ------------------- to fix the stuttery page content fade-up ----------------------------

			// The stuttery fade-up in firefox is caused the presence of the video.
			// It doesn't matter if the video's playing or not, just that it's there
			// the only time the transition is smooth is when the the video src isn't set

			// (also tried it with different power settings, still stuttery)

			// so if url has #aboutus on load, delay setting the video src until the
			// pageContent fade-up transition has completed

			// NB tested this and it almost certainly makes a difference
			// it's possible that some of the problem is hardware acceleration in firefox
			// tried that off, but it was generally better on

			// get a reference to one of the transitioning page content elements
			const pageContentHeading = document.querySelector(".section-pagecontent__heading");

			// the following let is a ref id for the setTimeout that we create below
			// think the returned value from a setTimeout is an integer id
			let transitionEndFallback: number;

			if (location.hash === "#aboutus") {
				// think we can delete this whole condition
				// just run the doSetSource()
				// no idea what it's doing (why did the video need to wait for pageHeadingTransition????)
				// leave it for now but revisit
				// comment it out and put a doSetSource in instead, see what happens...

				// right, think it's a hangover from when we trying to stop the video playing until
				// all the aos animations had finished bc we thought they might be making the video jittery
				// but i can't see anything else left of that code, whatever it was, so i reckon this whole
				// #aboutus pageheading transitionend handler stuff can go

				/*
				console.log("setting transitionend listener");
				pageContentHeading.addEventListener("transitionend", pageContentTransitionEndHandler);
				// pageContentHeading.setAttribute("data-event-transitioneend", "true");

				// in the case of a page reload when url is #aboutus and user has scrolled back to the top
				// i.e. the video is showing and playing, the reload will not set video source
				// because it's waiting for the page content transitionend, but that won't come until the
				// page content is in view (or close enough to the view port for the intersection observer to do its thing)
				// so we need a fallback
				// probably a settimeout, say half a second
				// the timeout will need to be cancelled by the transition end
				// it's initialised above - typescript doesn't like it being declared inside an if
				transitionEndFallback = setTimeout(pageContentTransitionEndHandler, 500);
				*/

				// testing...
				doSetSource();
			} else {
				doSetSource();
			}

			// following 2 functions are only required by setSource
			// so they're nested inside setSource

			// named function for the event listener
			// so it can be removed once it has run
			function pageContentTransitionEndHandler() {
				console.log("page content transitionend!");
				doSetSource();
				pageContentHeading.removeEventListener("transitionend", pageContentTransitionEndHandler);
				// cancel the fallback timeout
				clearTimeout(transitionEndFallback);
				console.log("clear the fallback timeout");
			}

			// the actual set source procedure
			function doSetSource() {
				// probably don't need any conditional now (was if (!videoElement.src)),
				// set source should only be called once (from one place)
				console.log("setting video source (and adding --show class)");
				videoElement.src = videoSource;
				// fade-in the video
				// now we're using filter: blur, the video doesn't fade in, the blur fades out
				// so the modifier class goes on the container, not the element
				// videoElement.classList.add("video-element--show");
				// are we sure we want the --show class to be added here?
				// why not when the video is ready?

				// yeah it needs to be when video is ready, which is handled by the initialise script (initialise.ts)
				// videoElement.parentElement?.classList.add("video-container--show");
			}
		}

		// this was window.onload but we're using the window load event quite a lot
		// so addEventListener is safer
		// addAutoplay() is only in case of videos that aren't on the home page
		// and have the data-autoplay attribute set to false
		// (homepage video currently has autoplay set true, through the prop videoAutoplay)
		window.addEventListener("load", () => {
			// setSource();
			addAutoplay();
		});
	} // end if
</script>

<style define:vars={{ backgroundImageTiny, backgroundImageLQIP, transitionDuration }}>
	/*
	.video-status {
		color: white;
		background-color: var(--accent);
		position: absolute;
		top: 0;
		left: 0;
		padding: 1rem;
		z-index: 1000;
	}
	*/

	/* probably need a container for the video, if only for postion relative */

	.video-container {
		/* parent (.hero) has display flex */
		/* so we can put the background on the container */
		/* then the video can fade in over the top  */

		position: relative;
		/* border: 1px solid blueviolet; */

		flex-grow: 1;

		/* don't need an imageset here, just one 20px jpg */
		/* background-image: -webkit-image-set(var(--backgroundImageSet)); */
		/* background-image: image-set(var(--backgroundImageSet)); */

		/* background-image: var(--backgroundImageLQIP), var(--backgroundImageTiny); */
		background-image: var(--backgroundImageLQIP);
		/* background-color: #f0f; */
		/* background-color: hsl(var(--offwhite)); */
		/* position was top center but it's not lining up with the image, */
		/* try center center (just center should do it) - yeah that's it*/
		background-position: center;
		background-size: cover;

		/* trying filter: blur instead of the opacity fade-in */
		/* so we can get the placeholder bg image compressed more without it looking acky */
		filter: blur(1rem);

		/* from PictureFullWidth hero__picture */

		/* video doesn't like any of these - probably bc its a flex item */
		/* (it has a container div which is a flex item, unlike the image which has picture) */

		/* width: 100%; */
		/* height: 100%; */
		/* display: block; */

		/* keep as position absolute, even though section-picture__picture is position: relative - trust me */
		/* position: absolute; */
		/* z-index: 0; */

		/* border: 1px solid #f00; */
	}

	/* the --show modifier needs to go on the container now, bc that's where the filter blur is */
	/* so that's what needs to transition */

	.video-container--show {
		/* trying filter: blur instead of the opacity fade-in */
		/* so we can get the placeholder bg image compressed more without it looking acky */
		transition: filter var(--transitionDuration);
		/* transition: filter 5s; */
		filter: blur(0rem);
	}

	/* apply the background-images in a separate class, so we have the option to not use them if the video is already loaded */
	/* not sure this is useful, if the video is in cache then so will the background-images */
	.video-container--background-images {
	}

	.video-element {
		/* border: 1px solid #00f; */
		/* width and height are very important here! */
		/* without them the video won't scale to fit the container */
		/* so object-fit won't work as intended */
		width: 100%;
		/* height: auto; */
		/* height needs to be 100% or it won't overflow horizontally on mobile (portrait) */
		/* it'll just scale to be wide enough to fit the display */
		height: 100%;

		/* The <video> element is a replaced element — its display value is inline */
		/* new reset should cover this now (uses vertical align instead of display: block) */
		/* display: block; */
		object-fit: cover;

		/* ------------------------------ if the video position goes awry ------------------------------- */
		/* ok, think we've fixed this now, it was because the video-element was using min-height not height */
		/* so the aspect ratio of the video was forcing video-element to be higher than the vh minus navheight */
		/* so hopefuly we won't need any of this position: absolute rigmarole */

		/* to keep the video horizontally centered but starting from the top */
		/* not sure why these rules were here, seems fine without them */
		/* and the video now lines up with the background image better */
		/* but keep an eye on things, it must have served some purpose */
		/*
		position: absolute;
		top: 0;
		left: 50%;
		transform: translateX(-50%);
		*/

		/* --------------------------------------------------------------------------------------------- */

		/* bg has to go on element, not container */

		/* border: 1px solid fuchsia; */
		/* background-color: hotpink; */

		/* hopefully won't need this opacity transition, now we're using filter blur */
		/* opacity: 0; */

		/* transition-duration was 250ms - way too short */
		/* needs to be long otherwise it looks like a janky shift */

		/* transition: opacity ease-in; */
		/* transition-duration needs setting separately because it's using a custom property? are you sure? */
		/* transition-duration: var(--transitionDuration); */
		/* transition: opacity var(--transitionDuration) ease-in; */

		/* will-change: opacity; */

		/* from pictureFullWidth hero__image */
		max-width: initial; /* keep this in for now, can't remember what it's doing! */
		/* width: 100%; */
		/* height: 100%; */
	}

	/* this class is applied by setSource() (see above) */
	.video-element--show {
		/* hopefully won't need this opacity transition, now we're using filter blur */
		/* opacity: 1; */
	}
</style>
