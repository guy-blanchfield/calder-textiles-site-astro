<!-- see: https://www.youtube.com/watch?v=-HS9IIuT_Mo&t=418s -->
<!-- or, if you want something fancier https://www.youtube.com/watch?v=Gx35fMhDPWs -->

<!-- might need to do something to disable scroll while preloader is showing -->
<!-- yeah really need to do this! -->

<!-- lets create this div with the script, so we can be sure it's ready in time -->
<!-- the script here isn't deferred -->
<!-- tried that, didn't take for some reason -->
<div class="loader loader--blank"></div>

<!-- try is:inline here so it loads quicker (and before the google map stuff) -->
<script is:inline>


// maybe put the init function in a separate module and import it, if that'll work

// this is where we put anything that needs to happen after the loader is done
// but isn't part of the loader
function initialise() {

    console.log("initialise!!!!!!!!");

    // this needs to happen on transition end as well, if it hasn't happened
    function showHeroText() {

        console.log('showHeroText function is running');
        console.log(`hero__text: ${document.querySelector('.hero__text')}`);

        const heroTextDiv = document.querySelector('.hero__text');

        // if the --visible class isn't there, add it
        if (!heroTextDiv.classList.contains('hero__text--visible')) {
            heroTextDiv.classList.add('hero__text--visible');
            console.log(`hero__text--visible class added!`)
        }
    }

    // think we need to move the fonts ready check into the loader
    // incorporate the fonts ready check with the loader , not check it after the loader has finished
    // it should also be inside the !preloadComplete condition
    // we don't need to check fonts for each page

    function fontFaceSetIteratorToArray(target) {
        const iterable = target.entries();
        const results = [];
        let iterator = iterable.next();

        while (iterator.done === false) {
            results.push(iterator.value);

            iterator = iterable.next();
        }

        return results;
    }

    async function fontsReady() {
        let ready = await document.fonts.ready;
        console.log(ready);
        console.log(fontFaceSetIteratorToArray(document.fonts));
        // console.log(`Baskerville: ${document.fonts.check('Baskerville Normal')}`);
        console.log('fonts should be ready');
        // showHeroText();
    }

    // this is going to check that the hero image is loaded
    // or if it's video, whether the video has loaded enough to play a bit
    async function heroImageReady() {
        // const heroImage: HTMLImageElement = document.querySelector('hero__image');
        // check if hero__image exists i.e. it's not a hero video instead
        const heroImage = document.querySelector('.hero__image');
        if (heroImage) {
            let ready = await heroImage.decode();
            console.log(ready);
            console.log('hero image should be ready');
            showHeroText();
        } else {
            console.log(`must be video, this should resolve!?`)
            // Video.readystate >= 3 is the condition you're looking for
            // or there's a canplay event, might be better
            const heroVideo = document.querySelector('.video-element');
            if (heroVideo) {
                heroVideo.addEventListener('canplay', showHeroText);
            }
        }
        
    }

    // fontsReady().then(heroImageReady).then(showHeroText);
    // only chain fontsReady and imageReady and call showHeroText
    // manually in the image if clause of imageReady and add an event listener 
    // in the video else clause to call showHeroText
    // because I can't find a way to get the video check to return a promise, i.e. can't be awaited
    fontsReady().then(heroImageReady);

    // Ok, the issue here is that before showHeroText can run, 3 conditions need to be met
    // 1. fonts are loaded
    // 2. hero image or first bit of hero video is loaded
    // 3. if the preloader is running it needs to have finished and faded out

}
    // try something like this
    // (it's ok we don't need cookie consent to do this!)
    // (sesion storage is considered strictly necessary)
    // https://stackoverflow.com/questions/48054601/how-to-show-website-preloader-only-once

    // right, what's gonna happen with the preloader is this.
    // if it takes more than a certain time to load, we add a --loading class to the preloader div
    // the --loading class has the ::after so the spinner appears
    // and a transition rule, so it fades when the --hidden class is applied

    // otherwise the window load event will just add the --hidden class to the preloader div
    // and the transition (fade) will happen every time you reload the page or go to a new page

    // think the best option is to make the loader blank (tried white, the dark blue is better) 
    // up until it's required to start looking like a loader
    // then it'll cover the ugly stuff but not flash up like a loader when load is instantaneous

    // NB don't get thrown by the blue background that will always flash before the hero image is loaded

    // yeah this way is not that different to no loader when load is instant, just that the nav disappears momentarily
    // this'll do for now

    // remove session storage item for testing
    // console.log(`storage item removed`);
    // sessionStorage.removeItem('preloadComplete');
    // console.log(`session storage item is now: ${sessionStorage.getItem('preloadComplete')}`);

    const preLoader = document.querySelector('.loader');

    // if preloadComplete hasn't been set yet
    // go ahead and show the loader
    // (add loader--loading to the classlist)

    // so ensure loader is hidden to start off with in <style>

    if (!sessionStorage.getItem('preloadComplete')) {

        // only add the loader--loading class if we need the loader
        // because that class adds the transition
        // we don't want the transition happening every time a new page loads
        // loader--loading also adds the animation, using ::after
        preLoader.classList.add('loader--loading');
        console.log(`loader is now loader--loading because preloadComplete is: ${sessionStorage.getItem('preloadComplete')}`);
        
        // add eventlistener for the transitionend when the loader fades out
        // when it fires, set loader visibility to hidden so it doesn't interfere with links and buttons

        preLoader.addEventListener('transitionend', () => {
            preLoader.classList.add('loader--hidden');
            console.log('transitionend event fired - preloader visibility hidden');

            // this is the first place we need to call the initialise function
            // i.e. when the window load event has fired AND the preloader has finished its fade out
            // the preloader fade out is initiated by adding the class 'loader--transparent' to the preloader
            initialise();

        });

        console.log(`transition event listener added`);

        window.addEventListener('load', () => {

            // clear the timeout, so the --loading class doesn't get added
            // so there won't be a transition when the --transparent class gets added
            // clearTimeout(startLoaderTimeout);
            // console.log(`the timeout cleared!`);

            preLoader.classList.add('loader--transparent');
            console.log(`load event fired!`);

            // don't forget to uncomment this!!!! ------------------------------------- < important!
            sessionStorage.setItem('preloadComplete', 'true');
            console.log(`preloadComplete is now: ${sessionStorage.getItem('preloadComplete')}`);

        });

        console.log(`load event listener added`);

    } else {
        console.log(`loader is not showing because preloadComplete is: ${sessionStorage.getItem('preloadComplete')}`);
        // hide the loader
        preLoader.classList.add('loader--transparent');
        // set loader visibility to hidden so it doesn't interfere with links and buttons
        preLoader.classList.add('loader--hidden');

        // this is the second place we need to call the initialise function
        // i.e. if preloadComplete is already set and we're skipping the loader

        // No! No! No!
        // initialise can't run just cos there's no preloader
        // it has to wait till the hero image is complete
        // put the initialise in an event listener for domcontentloaded
        // otherwise we can't get a reference for heroImage.decode
        window.addEventListener('DOMContentLoaded', () => {
            initialise();
            console.log(`dom content must be loaded!`);
        });
        // initialise(); 
        
    }

    // console.log("preloader script running");

</script>





<style>

    /* NB google maps z-index appears to be 1000000 plus a few; */
    /* so I suppose we're gonna have to go 1000100 or maybe 2000000! */

    .loader {
        position: fixed;
        z-index: 1000100;
        inset: 0;
        background-color: hsl(var(--darkergrey));
        /* border: 1px solid hotpink; */
        color: hsl(var(--white));
        width: 100vw;
        height: 100vh;
        align-items: center;
        justify-content: center;
        display: flex;

        /* visibility: hidden; */
    }

    .loader--loading {
        /* background-color: hsl(var(--darkergrey)); */
        /* visibility isn't transitionable? */
        /* transition: opacity 0.5s, visibility 0.5s; */
        background-color: hsl(var(--darkblue));
        transition: opacity 0.5s ease-in;
    }

    .loader--loading::after {
        content: '';
        display: flex;
        width: 70px;
        height: 70px;
        border: 5px solid hsl(var(--lightbluegrey));
        /* border-top-color so a quarter of the circle is a different colour */
        border-top-color: hsl(var(--white));
        border-radius: 50%;

        animation: loading 0.75s linear infinite;
    }

    @keyframes loading {
        from { transform: rotate(0turn) }
        /* 50% { transform: scale(0.75) } */
        to { transform: rotate(1turn) }
    }

    .loader--transparent {
        opacity: 0;
    }

    .loader--hidden {
        /* visibility breaks the transition */
        /* but we definitely need it hidden otherwise no links or buttons work! */
        /* so add this class with an event listener for transition end */
        /* also add it if preloadComplete is true */
        visibility: hidden;
    }
    
</style>