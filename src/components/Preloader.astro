---
---

<!-- see: https://www.youtube.com/watch?v=-HS9IIuT_Mo&t=418s --><!-- or, if you want something fancier https://www.youtube.com/watch?v=Gx35fMhDPWs --><!-- might need to do something to disable scroll while preloader is showing --><!-- yeah really need to do this! --><!-- lets create this div with the script, so we can be sure it's ready in time --><!-- the script here isn't deferred --><!-- tried that, didn't take for some reason -->
<div class="loader loader--blank"></div>

<script>
	import initialise from "../js/initialise";

	// right, what's gonna happen with the preloader is this.
	// if it's the first time the site has loaded we set session storage item
	// then check for that session storage item on each page load

	// if the item is NOT set, add the loader--loading class

	// if the item IS set hide the loader (add the loader--transparent & loader--hidden classes)
	// set a domcontentloaded event listener with the initialise function as a callback

	// the --loading class has the ::after so the spinner appears
	// and a transition rule, so it fades when the --hidden class is applied

	// otherwise the window load event will just add the --hidden class to the preloader div
	// and the transition (fade) will happen every time you reload the page or go to a new page

	// ------------------- refs ------------------------------------------------------

	// first get a reference to the preLoader element
	// this will be passed into the functions
	const preLoader: HTMLElement = document.querySelector(".loader");

	// ------------------- functions ------------------------------------------------------

	function showLoader(loader: HTMLElement) {
		// only add the loader--loading class if we need the loader
		// because that class adds the transition, and we don't
		// want the transition happening every time a new page loads

		// loader--loading also adds the spinning circle animation, using ::after
		loader.classList.add("loader--loading");

		// also add a class to the body to prevent scrolling while loader is showing
		document.body.classList.add("loader-showing");
		console.log(`adding loader classes`);
		console.log(`loader showing, preloadComplete: ${sessionStorage.getItem("preloadComplete")}`);
	}

	function hideLoader(loader: HTMLElement) {
		// hide the loader
		loader.classList.add("loader--transparent");
		// set loader visibility to hidden so it doesn't interfere with links and buttons
		loader.classList.add("loader--hidden");

		console.log(`loader not showing, preloadComplete: ${sessionStorage.getItem("preloadComplete")}`);
	}

	function handleTransitionEnd() {
		// set preloader visibility to hidden
		this.classList.add("loader--hidden");
		console.log("transitionend event fired - preloader visibility hidden");
		// remove the body class that was disabling scrolling
		document.body.classList.remove("loader-showing");
		console.log("remove body class loader-showing");

		// this is the first place we need to call the initialise function
		// i.e. when the window load event has fired AND the preloader has finished its fade out
		// the preloader fade out is initiated by adding the class 'loader--transparent' to the preloader
		initialise();
	}

	function handleWindowLoad(loader: HTMLElement) {
		console.log(`load event fired!`);
		preLoader.classList.add("loader--transparent");

		// set the session storage item to log that preload has been completed
		sessionStorage.setItem("preloadComplete", "true");
		console.log(`preloadComplete is now: ${sessionStorage.getItem("preloadComplete")}`);

		// unhide the content
		// maybe think about putting these into initialise
		// if we want to be sure that the fonts are loaded before we show *anything*
		// then they should go in initialise
		// certainly consider it if we change from the native font stack to tex gyre heros
		document.querySelector(".content-wrapper").classList.remove("hidden");
		console.log("unhide the content wrapper!");
	}

	// ------------------- end functions --------------------------------------------

	console.log("preloader running");

	// sessionStorage preloadComplete is set by handleWindowLoad function (above)
	if (!sessionStorage.getItem("preloadComplete")) {
		// if preloadComplete hasn't been set yet
		// go ahead and show the loader animation
		// (by adding loader--loading to the classlist)
		showLoader(preLoader);

		// add eventlistener for the transitionend when the loader fades out
		// when it fires, set loader visibility to hidden so it doesn't interfere with links and buttons
		preLoader.addEventListener("transitionend", handleTransitionEnd);
		console.log(`transition event listener added`);

		// add eventlistener for the window load event, fires when everything is loaded (except lazy loaded images)
		// the callback / handler will hide the loader, show the content and set the sessionstorage item
		window.addEventListener("load", () => handleWindowLoad(preLoader));
		console.log(`load event listener added`);
	} else {
		// this is what happens if there's no preloader
		// i.e. the session storage item 'preloadcomplete' has already been set

		// hide the preloader
		hideLoader(preLoader);

		// this is the second place we need to call the initialise function
		// i.e. if preloadComplete is already set and we're skipping the loader

		// but we can't initialise until the hero image is complete
		// otherwise we can't get a reference for heroImage.decode
		// so put the initialise in an event listener for domcontentloaded
		window.addEventListener("DOMContentLoaded", initialise);
	}
</script>

<style>
	/* to disable scrolling while loader is showing */
	body.loader-showing {
		/* height: 100vh; */
		/* overflow-y: hidden; */
		position: fixed;
		/* this is width for horizontal writing-mode */
		inline-size: 100%;
		overflow-y: scroll;
	}

	body.loader-hidden {
		/* static is the default position for body */
		position: static;
		overflow-y: auto;
	}

	/* NB google maps z-index appears to be 1000000 plus a few; */
	/* so I suppose we're gonna have to go 1000100 or maybe 2000000! */

	.loader {
		position: fixed;
		z-index: 1000100;
		inset: 0;
		/* background-color not here, on loader--loading instead, otherwise it covers the page in blue briefly everytime */
		/* background-color: var(--accent); */
		/* border: 1px solid hotpink; */
		color: hsl(var(--white));
		width: 100vw;
		height: 100vh;
		align-items: center;
		justify-content: center;
		display: flex;

		/* visibility: hidden; */
	}

	.loader--loading {
		background-color: var(--accent);
		/* background-color: hsl(var(--darkergrey)); */
		/* visibility isn't transitionable? */
		/* transition: opacity 0.5s, visibility 0.5s; */
		/* background-color: var(--accent); */
		transition: opacity 0.5s ease-in;

		/* will-change: opacity; */
	}

	.loader--loading::after {
		content: "";
		display: flex;
		width: 70px;
		height: 70px;
		border: 5px solid var(--accent-2);
		/* border-top-color so a quarter of the circle is a different colour */
		border-top-color: hsl(var(--white));
		border-radius: 50%;

		animation: loading 0.75s linear infinite;
	}

	@keyframes loading {
		from {
			transform: rotate(0turn);
		}
		/* 50% { transform: scale(0.75) } */
		to {
			transform: rotate(1turn);
		}
	}

	.loader--transparent {
		opacity: 0;
	}

	.loader--hidden {
		/* visibility breaks the transition */
		/* but we definitely need it hidden otherwise no links or buttons work! */
		/* so add this class with an event listener for transition end */
		/* also add it if preloadComplete is true */
		visibility: hidden;
	}
</style>
