---
// needs a class for the picture element AND a class for the img element inside
// (it's not just a fallback - its the img element that displays the image)

// named them somethingClasses just in case we need more than one
// at the moment we're only using one

// we don't want the browser trying to dowwnload a portrait image if it's not required
// i.e. if it's the body picture element (currently section-bigpicture) not the hero picture
// we can't just use a css media query to hide the big picture section on mobile, because the browser might have started
// trying to download it by the time it parses the css
// so we need to have some conditional in this component so that the portrait stuff isn't included

// ok, we have a conditional for lazy loading, so the hero image can load eagerly
// and any full width pictures in the body can lazy load, therefore not downloading immediately
// and so when the css loads and sets display:none for mobile, modern browsers won't download it at all
// hopefully!

export interface Props {
	imageBase: string;
	imageAlt?: string;
	pictureClasses: string; // e.g. hero__picture
	imageClasses: string; // e.g. hero__image
	// includePortrait?: boolean;
	lazyLoad?: boolean;
	// might as well have a prop for the fade transition time
	// that will go into a data-attribute
	// it will be used in the css to set duration of the fade in when the image or video is ready to display
	// and also to set the timeout duration of handleHeroTextTransition() (in initialise.ts)
	// i.e. the hero text fade-up has to wait for the image or video fade-in to finish
	transitionDuration?: string; // properties of dataset are strings
	transitionDelay?: string;
}

// think lazyLoad should be true as default, only the hero picture needs to eager load

const {
	imageBase,
	imageAlt = "",
	pictureClasses,
	imageClasses,
	lazyLoad = true,
	transitionDuration = "300ms",
	transitionDelay = "100ms",
} = Astro.props;

// just create the whole string for each srcset
// it'll be way tidier than creating objects and arrays to generate the the string dynamically
// see scripts/srcset-stuff.js for the long winded option

// NB these images all have to go in public!

// const portraitSrcset = !includePortrait ? `/images/blank-1px.png` : `/images/${imageBase}-portrait-540x960.jpg 540w, /images/${imageBase}-portrait-810x1440.jpg 810w, /images/${imageBase}-portrait-1080x1920.jpg 1080w`;
const portraitSrcset = `/images/${imageBase}-portrait-540x960.jpg 540w, /images/${imageBase}-portrait-810x1440.jpg 810w, /images/${imageBase}-portrait-1080x1920.jpg 1080w`; // 9:16
const portraitSrcsetWebp = `/images/${imageBase}-portrait-540x960.webp 540w, /images/${imageBase}-portrait-810x1440.webp 810w, /images/${imageBase}-portrait-1080x1920.webp 1080w`; // 9:16
//const landscapeSrcset = `/images/${imageBase}-960x720.jpg 960w, /images/${imageBase}-1440x960.jpg 1440w, /images/${imageBase}-1920x1440.jpg 1920w, /images/${imageBase}-2400x1600.jpg 2400w`; //4:3
// largest 2360x1330
const landscapeSrcset = `/images/${imageBase}-960x540.jpg 960w, /images/${imageBase}-1440x810.jpg 1440w, /images/${imageBase}-1920x1080.jpg 1920w, /images/${imageBase}-2360x1330.jpg 2560w`; // 16:9
// largest 2560x1440
// const landscapeSrcset = `/images/${imageBase}-960x540.jpg 960w, /images/${imageBase}-1440x810.jpg 1440w, /images/${imageBase}-1920x1080.jpg 1920w, /images/${imageBase}-2560x1440.jpg 2560w`; // 16:9
// largest 2360x1330
// try leaving the the highest resolution webp out, just for better lighthouse performance score
// 1920 is good enough resolution on a 3840x2400 screen, and performance score is 97, so keep like this for the time being
// const landscapeSrcsetWebp = `/images/${imageBase}-960x540.webp 960w, /images/${imageBase}-1440x810.webp 1440w, /images/${imageBase}-1920x1080.webp 1920w, /images/${imageBase}-2360x1330.webp 2560w`; // 16:9
const landscapeSrcsetWebp = `/images/${imageBase}-960x540.webp 960w, /images/${imageBase}-1440x810.webp 1440w, /images/${imageBase}-1920x1080.webp 1920w`; // 16:9
// largest 2560x1440
// const landscapeSrcsetWebp = `/images/${imageBase}-960x540.webp 960w, /images/${imageBase}-1440x810.webp 1440w, /images/${imageBase}-1920x1080.webp 1920w, /images/${imageBase}-2560x1440.webp 2560w`; // 16:9

const fallbackSrc = `/images/${imageBase}-960x540.jpg`;

// need to create image path variable to pass into style
// using define:vars
// for the 20px blurry background-image, that shows while the big picture is loading
// it's used as a background-image on section-picture__picture (see the style section below)

// no portrait versions for the picture section so the 20px version will always 20x11 (16x9)
// this'll probably have to go in public

// NB has to be the whole background-image value - url() and all

// image-set - remember to put the best format first it'll use the first compatible format it comes across
// const backgroundImageSet = `url(/images/${imageBase}-50x28.webp) type("image/webp"), url(/images/${imageBase}-50x28.jpg) type("image/jpeg")`;
// tried 50px images - nah, 20 probably better

// the 20px background images are so small, there's no point having a webp as well as jpg
// const backgroundImageSet = `url(/images/${imageBase}-20x11.webp) type("image/webp"), url(/images/${imageBase}-20x11.jpg) type("image/jpeg")`;
// const backgroundImageSet = `url(/images/${imageBase}-20x11.jpg) type("image/jpeg")`;

// in which case there's no need for imageset, just use background-image to stack/layer
// two images, one 20px (tiny, really blurred), one the LQIP
// the tiny one will load first, the lqip will replace it (layer over the top of it) as soon as it's loaded

//  if we want to set background image conditionally, e.g different bg images for Hero and pictureSection
// we should be able to use the pictureClasses prop
// in the Hero component pictureClasses will contain 'hero__picture'
// in the pictureSection component pictureClasses will contain 'section-picture__picture'

/*
const backgroundImage = pictureClasses.includes("hero")
	? `url(/images/${imageBase}-lqip-blur.jpg)`
	: `url(/images/${imageBase}-20x11.jpg)`;
*/

// think we're just going to use the blur for both hero and pictureSection, at least for now
// consider using backdrop-filter blur, then we could just use a really low quality version of the image
// and blur it in the browser, caniuse says 96.5% for backdrop-filter so give it a go

const backgroundImage = `url(/images/${imageBase}-lqip.jpg)`;

// const backgroundImageTiny = `url(/images/${imageBase}-20x11.jpg)`;
// const backgroundImageLQIP = `url(/images/${imageBase}-lqip-blur.jpg)`;
---

<picture class:list={pictureClasses}>
	<!-- just use media min-width for now -->
	<!-- add something for orientation (e.g. media="(orientation: portrait)") eventually -->

	<!-- see: https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images -->
	<!-- probably want to do something like: -->

	<!-- <source media="(orientation: portrait)" srcset=".assets/images/{someimage}-portrait-320.jpg, {someimage}-portrait-480.jpg 1.5x, {someimage}-portrait-640.jpg 2x" > -->
	<!-- <source media="(max-width: 1200px)" srcset="./assets/images/{someimage}-320.jpg, {someimage}-480.jpg 1.5x, {someimage}-640.jpg 2x" > -->

	<!-- maybe you don't need the media orientation explicitly, just assume it from the min/max-width -->
	<!-- just remember that srcset takes multiple files, for multiple display resolutions -->

	<!-- more about the picture issue from a well regarded article by jason grigsby -->
	<!-- https://cloudfour.com/thinks/responsive-images-101-part-3-srcset-display-density/ -->

	<!-- "The moment you move beyond providing alternate densities of a fixed width img element, the display density descriptor becomes unwieldy and inadequate to the task." -->
	<!-- so density descriptor is a no-no then -->

	<!-- NB on tests with this laptop (density 2.5x) the image with the 3x descriptor is the chosen over 1x, but 2x is chosen over 3x -->
	<!-- 1.5x is chosen over 1x, 3x is chosen over 1.5, 2.5 over 3x -->

	<!-- on tests with this laptop (density 2.5px) at 1500 viewport, 2880w is chosen over 1440w -->
	<!-- at 400 viewport, 1440w is chosen (it's looking for an image 2.5 x 400 so 1000px, and 1440 is big enough) -->
	<!-- it should choose the 2880w if viewport gets bigger than 576 (at the point where 1440 isn't enough (1440/2.5 = 576)) Yep! -->

	<!-- So, as long as we provide 2 or 3 different resolution images for both orientations -->
	<!-- it probably doesn't matter whether we use density descriptor or width descriptor -->
	<!-- width probably easiest to deal with -->

	<!-- For portrait it's probably always going to be mobiles, so for a full width image we need say 400, 800, maybe 1200  -->
	<!-- typical aspect ratio for smart phones is 9:16 - 9:20 -->

	<!-- using portrait images on viewports between 576 and 768 looks weird and wrong -->
	<!-- so use an 'and' here to specify a min-width condition -->
	<!-- viewports that are portrait and between 576 and 768 will get the fallback image -->

	<source media="(orientation: portrait) and (min-width: 768px)" srcset={portraitSrcsetWebp} type="image/webp" />
	<source media="(orientation: portrait) and (min-width: 768px)" srcset={portraitSrcset} type="image/jpeg" />

	<!-- because this is picture so there's no 'sizes', browser will assume the image to be 100vw (correctly in this case!) -->
	<!-- so we probably don't need any other media query, just let the browser select the best image based on the device pixel density -->

	<!-- query here was originally min-width: 768px, but that meant that at landscape orientations less than 768 -->
	<!-- no image at all was shown (why the fallback image didn't apply, who knows? duh the jpgs hadn't been created! should work now) -->
	<!-- either way, try orientation: landscape instead -->
	<source media="(orientation: landscape)" srcset={landscapeSrcsetWebp} type="image/webp" />
	<source media="(orientation: landscape)" srcset={landscapeSrcset} type="image/jpeg" />
	<!-- <source srcset="./assets/images/${heroImage}-1440x960.jpg 2880w, ./assets/images/${heroImage}-2000x1333.jpg 1440w" media="(min-width: 100px)"> -->
	<!-- <source srcset="./assets/images/${heroImage}-1440x960.jpg" media="(min-width: 1200px)"> -->

	<!-- the fallbackSrc will apply to anything under 768 wide and orientation landscape -->
	<!-- the loading=lazy will stop the browser immediately downloading its chosen image -->
	<!-- which should give the css time to parse and set display to none -->

	<!-- in tests so far, with loading=lazy and display:none: -->
	<!-- firefox doesn't download the image -->
	<!-- chrome doesn't download the image -->
	<!-- edge doesn't download the image -->

	<!-- width and height settings to aid lazy loading -->
	<!-- fallbacksrc is 960x540 so try that -->

	<img
		src={fallbackSrc}
		alt={imageAlt}
		class:list={imageClasses}
		loading={lazyLoad ? "lazy" : "eager"}
		data-transition-duration={transitionDuration}
		data-transition-delay={transitionDelay}
		width="960"
		height="540"
	/>
</picture>

<!-- <script define:vars={{ fallbackSrc }}> -->
<script>
	// wait for the image to load, then transition the opacity
	// think this script will only run once, not once for each instance of the component
	// so grabs the img inside all pictures with class picture--blur-load

	const pictureElements = document.querySelectorAll(".picture--blur-load");

	// pictureElements.forEach((pictureEl) => {
	for (const pictureEl of pictureElements) {
		const pictureImg = pictureEl.querySelector("img");

		// check if the image is loaded first
		// otherwise add a load event listener

		// NB! if the all the srcSet images fail (e.g. 404s)
		// pictureImg.complete will return true
		// so we need to test whether the src image exists
		// maybe try getting the height / width of the image?
		// if the image has loaded these will be positive values otherwsie they'll be 0

		// done plenty of testing and fairly sure .complete and .naturalWidth can be relied on
		// to refer to the image chosen by the browser from srcset
		// NOT the fallback path that's in src to start off with
		// the value for naturalWidth IS related to the vw i.e. the way the browser renders the image
		// but we only need to know that it's NOT zero

		// it's probably firefox's throttling / caching that can't be trusted
		// that's what's causing the script to go straight to picture--show
		// even when throttled (hence not showing the blur lqip, but still waiting for the hq image to download)
		// hopefully in a live environment this won't happen...?!

		console.log(`complete: ${pictureImg.complete}, naturalWidth: ${pictureImg.naturalWidth}`);
		// temp for testing
		// const alwaysFalse: boolean = false;

		if (pictureImg?.complete && pictureImg?.naturalWidth) {
			// we want a different process here
			// from when the load event fires
			// bc if the image is already loaded
			// it doesn't really need the blur fade transition
			// (it's probably already been downloaded previously)
			// add 'blur-loading' NOT 'blur-load' (which is the class that identifies which images want a blur-load)
			// imgLoaded(pictureEl);
			// maybe we don't need anything to happen here?

			// add blur-loading here just to test how it affects lighthouse
			// console.log("and also adding picture--blur-loading to test");
			// pictureEl.classList.add("picture--blur-loading");

			console.log(`${pictureImg.src} is complete so adding picture--show`);
			pictureEl.classList.add("picture--show");

			// add blur-loading here just to test how it affects lighthouse
			// console.log("and also adding picture--blur-loading to test");
			// pictureEl.classList.add("picture--blur-loading");
			// tests inconclusive: performance score ranges from 88-92 on all inside pages

			// right, just noting this here, performance score is related to the window size
			// so if the browser chooses a smaller image from srcset, performance score will be better
			// note that the lqip doesn't change (there are no smaller versions of the lqip)
			// so it must be about the size of the hq image
			// (we tried it without sectionPicture and scores were no different so it's the hero image that's the issue)

			// deleting / renaming the webp image (so it fails to load) improves performance score signingicantly - 99!)
			// so when lighthouse uses the lqip as lcp performance score is improved
			// can we conclude that lighthouse isn't using the lqip as lcp? try making a full resolution lqip 2360x1330?
			// no, bc lcp element is identified thus:

			// webp renamed: picture.hero__picture.picture--blur-load.astro-H4CVHZ34.picture--blur-loading (score 98)
			// or with picture--show forced:
			// picture.hero__picture.picture--blur-load.astro-H4CVHZ34.picture--blur-loading.picture--show (score 99)
			// webp normal and picture--show forced:
			// picture.hero__picture.picture--blur-load.astro-H4CVHZ34.picture--blur-loading.picture--show (score 89)

			// or sometimes it's img.hero__image.astro-H4CVHZ34 (score 90)

			// right, tested it with forced filter and opacity transitions AND the showHeroText transition
			// score is still higher without the big image, so it's probably not the transitions
			// probably safe to assume that when the lqip is lcp, score is high, when hq image is lcp, score is lower

			// is it possible that this is related to simulated throttling and what is actually happening is lighthouse
			// gets the hq image first and goes straight to --show instead of --blur-loading
			// nope - tested in devtools throttling mode and performance was better with the big image renamed
		} else {
			// add the class that sets a transition
			// so that picture--show will cause a fade when the load event fires

			console.log(`${pictureImg.src} is NOT complete so adding picture--blur-loading`);
			pictureEl.classList.add("picture--blur-loading");
			pictureImg.addEventListener("load", () => {
				console.log(`img load event fired so adding picture--show`);
				pictureEl.classList.add("picture--show");
			});
		}
	}
</script>

<style define:vars={{ backgroundImage, transitionDuration, transitionDelay }}>
	/* firstly, lets have 100% width and height, and display block for the picture elements */
	/* definitely need the width and height to make the picture */
	/* (and hence the image) fill its container (section-picture or hero) */

	/* picture's default display is not block, must be inline I suppose */
	/* so the picture wasn't expanding to contain the img */
	/* img was just overflowing it */
	/* display:block this should fix that */

	.hero__picture,
	.section-picture__picture {
		width: 100%;
		height: 100%;
		/* display:block replaced by vertical-align in the reset (added 12-11-2023) */
		/* display: block; */

		/* tried doing this as flex-grow: 1 (like the video container div), problematic, leave as is */
	}

	.hero__picture,
	.section-picture__picture {
		/* keep as position absolute, even though section-picture__picture is position: relative - trust me */
		position: absolute;
		z-index: 0;
	}

	/* narrower screens need section-picture__picture to be relative so the image can shrink */
	/* see the media query in pictureSection (min-width 992) for the min-height stuff */
	/* 992 is where it goes to a 2 column layout so it makes sense to put the query there */
	@media (max-width: 991px) {
		.section-picture__picture {
			/* keep as position: relative - trust me */
			position: relative;
		}
	}

	.hero__image,
	.section-picture__image {
		/* no pointer events because it's a background */
		pointer-events: none;
		/* max-width should be taken care of by the reset (added 12-11-2023) */
		/* max-width: initial; */
		width: 100%;
		height: 100%;
		/* https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit */
		/* please do some tests with this i need to understand it */

		/* i think i get it */
		/* "The object-fit CSS property sets how the content of a replaced element, such as an <img> or <video>, should be resized to fit its container." */
		/* container in the case of a replaced element is the img or video box itself NOT the parent */
		/* so you set some dimensions for the <img> and object fit determines how the actual image gets stretched or scaled to fit into its box */
		/* that's why the element needs width and height setting */

		/* so what we're doing here is telling the <img> to be the width and height of its parent */
		/* then telling the image how to fit into that <img> box using the object-fit rule */

		object-fit: cover;
		/* position: relative; */
		/* z-index: 9; */
		/* border: 1px solid yellow; */
	}

	/* any picture element that we want to be preloaded, with blurred bg and pulsing overlay is given the class 'picture--blur-load' */
	/* so it can be applied to hero image as well as section image */
	/* we can apply it by passing it as a prop (pictureClasses) to the pictureFullWidth component into the classlist*/

	/* 'picture--blur-load' sets opacity to 0 and identifies the element to the querySelectorAll */
	/* so it gets put into the nodelist (pictureElements) */

	/* another class called 'picture--blur-loading' is added by js once we've checked that the image isn't already loaded */
	/* this adds: */
	/*  - blurred bg image  */
	/*  - the transition property */
	/*  - the pulsing overlay (using ::before) */

	/* bc we don't want the blurred bg or transition or the pulsing overlay if the image is already loaded */

	/* if the image is already loaded OR when the img load event fires, 'picture--show is added' */
	/* this sets opacity to 1, which shows the image immediately if the picture only has 'picture--blur-load' */
	/* OR fades the image in if the picture has had 'picture--blur-loading' added */

	/* NB hero images *are* using the picture--blur-load class */
	/* but the blur bg image is hardly ever seen because the hero images preload */
	/* i.e. they're not lazy loaded, so they've usually loaded by the time the scripts get going */
	/* at least I think that's what's happening! */
	/* yeah, tested this plenty and the blur bg *will* be applied if the image takes long enough */

	.picture--blur-loading {
		/* background-image: -webkit-image-set(var(--backgroundImageSet)); */
		/* background-image: image-set(var(--backgroundImageSet)); */

		/* use background-image to stack/layer two images, 
		/* one 20px (tiny, really blurred),  */
		/* one the LQIP */
		/* the tiny one will load first, the lqip will replace it (layer over the top of it) as soon as it's loaded */
		/* NB!!!!! the image you want to be on top should go first */

		/* hard code this for testing */
		/* background-image: url("/images/pink-yarn-1440x810-lqip.jpg"), url("/images/pink-yarn-20x11.jpg"); */
		/* not sure about having two blurred images, one following the other */
		/* looks a bit odd, try without the tiny image, have to keep the lqip bc it's the lcp (tiny image doesn't qualify) */
		/* thing is, lcp is only a concern for hero images but this component handles the section images as well... */
		/* do we need some conditional? */
		/* background-image: var(--backgroundImageLQIP), var(--backgroundImageTiny); */
		/* only one backgroundImage now, which is set condtionally in the frontmatter */
		/* depending on whether the component is Hero or pictureSection */
		background-image: var(--backgroundImage);
		/* background-image: var(--backgroundImageLowRes), var(--backgroundImageMediumRes); */

		background-size: cover;
		/* probably need background-position so the background-image aligns with the img when it fades in */
		background-position: center center;

		/* hero__picture already has position: absolute because of the overlay stuff to put text over the image */
		/* position: relative won't work for hero__picture, it won't contain the img for a start */
		/* so we'll have to apply position: relative specifically to section-picture__picture */
		/* see below */

		/* filter: blur and associated transition needs to go on blur-load NOT blur-loading */
		/* otherwise the blur will fade in when the blur-loading class is applied*/

		/* try filter blur on --blur-load */
		/* so the image always fades in fom blur */
		/* otherwise it looks a bit acky and chrome sometimes appears to stretch it while its loading */
		/* better to blur each time than to look sketchy */
		/* filter: blur(1rem); */

		/* transition here means that the filter will fade in - we don't want that */
		/* we only want it to fade out, so transition should go on picture--show */
		/* transition: filter var(--transitionDuration) ease-in; */
	}

	/* try this as blur-loading for now, see what happens */
	/* not really sure was going on here, seems to be working ok without these */
	.section-picture__picture.picture--blur-loading {
		/* position: relative; */
	}

	.section-picture__picture {
		/* position: relative; */
		/* position: absolute; */
	}

	/* the pulsing overlay to indicate that something's happening */
	.picture--blur-loading::before {
		content: "";
		position: absolute;
		/* inset 0 is eqivalent to top 0 right 0 bottom 0 left 0 */
		/* so it fits the element to its parent */
		inset: 0;
		/* border: 1px solid fuchsia; */
		/* background-color: hsl(var(--white) / 0.5); */
		animation: pulsing-bg 2s ease-in-out infinite;

		/* backdrop-filter: blur to blur the image so we can get away with lower quality?! */
		/* maybe we should just use filter blur on the element?? */
		/* backdrop-filter: blur(1rem) opacity(1); */

		/* transition for the filter: blur */
		/* needs to match the transition on the picture--blur-load img ruleset below */
		/* transition: backdrop-filter var(--transitionDuration) ease-in; */
	}

	@keyframes pulsing-bg {
		0% {
			background-color: hsl(var(--white) / 0);
		}
		50% {
			background-color: hsl(var(--white) / 0.1);
		}
		100% {
			background-color: hsl(var(--white) / 0);
		}
	}

	/* the show/hide class has to go on the containing element (picture) not img */

	.picture--blur-load {
		/* filter: blur(1rem); */
		/* transition: filter var(--transitionDuration) ease-in; */

		/* try filter blur on --blur-load */
		/* so the image always fades in fom blur */
		/* otherwise it looks a bit acky and chrome sometimes appears to stretch it while its loading */
		filter: blur(1rem);

		/* clip-path because the filter: blur bleeds over the previous section */
		clip-path: inset(0);
	}

	.picture--blur-load img {
		/* just hides the image but doesn't set up a transition */

		/* opacity: 0 causes an LCP issue */
		/* see: https://www.debugbear.com/blog/opacity-animation-poor-lcp */
		/* opacity: 0; */

		/* opacity: 0.01; */
		/* ok, 0.1 fixes the LCP thing but now we see the image loading in vertically and then fade in */
		/* 0.01 seems to work ok and is pretty much invisible - 0.01 seems to be the lowest safe value for opacity (that isn't 0) */

		/* if we want the image to always fade in, put the transition declaration here */
		/* (and take it off blur-loading img - below) */
		/* think it's probably a bit nicer here - there's a little flash anyway so at least this looks a bit smoother */
		/* transition: opacity 250ms ease-in; */

		/* transition: opacity var(--transitionDuration) ease-in; */

		/* hopefully won't need the img opacity transtion now we're using filer blur */
		/* delete those rules above, when this is all done */

		/*  try hiding the image until its loaded so we don't see it loading in vertically */
		opacity: 0;
		/* opacity transition as well as filter blur transition seems like a bad idea cpu wise */
		/* ok, delay the filter transition, while we do the opcaity transition */
		transition: opacity var(--transitionDelay);
	}

	.picture--blur-loading img {
		/* opacity: 0; */
		/* put the transition here if we only want it to fade on images that are loading for the first time */
		/* transition: opacity 250ms ease-in; */
	}

	.picture--show {
		/* transition goes here, so it fades out but doesn't fade in */
		/* let's try a delay on this transition (transitionDelay) */

		/* from MDN: */
		/* The first value that can be parsed as a time is assigned to the transition-duration, 
		and the second value that can be parsed as a time is assigned to transition-delay */
		transition: filter var(--transitionDuration) var(--transitionDelay);
		filter: blur(0rem);
	}

	.picture--show img {
		/* hopefully won't need the img opacity transtion now we're using filer blur */
		opacity: 1;
	}

	/* something to remove the pulsing ::before */
	.picture--show::before {
		/* content: none; */
		animation: none;
		/* backdrop-filter: blur stays the same but we transition the opacity */
		/* backdrop-filter: blur(1rem) opacity(0); */
	}

	/* the height of section-picture needs to be set to 0 in PictureSection using the same media query */
	/* Or maybe not! Taken the height rule out of PictureSection - keep an eye on it, see how it goes */

	/* also, was 768, trying 576 */
	/* on second thoughts, let's leave the section pictures in on mobile, for the time being */
	@media (max-width: 576px) {
		.section-picture__picture {
			/* display: none; */
		}
	}
</style>
